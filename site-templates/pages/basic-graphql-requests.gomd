<h1>Basic GraphQL Requests</h1>

<p>
    <em>
        This guide assumes you have obtained an access token from an authorized user. You can obtain an access token
        by completing the OAuth flow (see the <a href="/docs/page/app-auth">Application Authorization</a> guide).
    </em>
</p>

<h3>The Request URL</h3>

<p>
    All GraphQL endpoints can be reached from the same url URL:
</p>

<pre>
<script type="text/javascript">
    document.write(apiBaseStr);
</script>/graphql
</pre>

<p>
    All operations require an <strong>Authorization</strong> header based on the access tokens received from the
    OAuth flow. The value of this header should match the format of <span class="pre">Bearer &lt;access-token&gt;</span>.
</p>

<h3>Assembling a Query</h3>

<p>The structure of a basic GraphQL query is as follows: </p>
<pre>
    {
        elements(workspaceId: "G1N2zzX2uGwMLMfLkmi") {
          __typename
          id
          transform {
              x y
          }
        }
    }      
</pre>
<p>
    This query is calling the <span class="pre">/workspace/{workspaceId}/elements</span>endpoint in order to retrieve all of the elemnts within that workspace,
    while also specifying exactly the information that should be returned. In this case the query will return the <span class="pre">id</span> and 
    <span class="pre">(x,y)</span> coordinates of all elements within the workspace.
</p>

<h4>Output</h4>
<pre>
    {
        "data": {
          "elements": [
            {
              "__typename": "Shape",
              "id": "60340962fbfaf42d19ab103f",
              "transform": {
                "x": -2074.9296875,
                "y": -538.6084806720415
              }
            },
            {
              "__typename": "Text",
              "id": "6034096bfbfaf42d19ab1042",
              "transform": {
                "x": -3160.056219160557,
                "y": 557.3029262622199
              }
            },
          ]
        }
      }
</pre>

<p>
    Quereies can be extended even further in order to drill down into the API in order to designate exactly what information the developer is looking
    for. This is really where the benefits of GraphQL start to shine. The following depicts an example where the developer only wants to retrieve
    information on shapes in the workspace, and additionally, only wants the <span class="pre">id</span> fields of those shapes:
</p>
<pre>
    {
        elements(workspaceId:"lVbvis7g6m4X872j6ovj", type: Shape) {
          __typename
          id
        }
      }
</pre>

<h4>Output</h4>
<pre>
    {
        "data": {
          "elements": [
            {
              "__typename": "Shape",
              "id": "60340962fbfaf42d19ab103f"
            }
          ]
        }
      }
</pre>

<p>
    This can even be taken one step further, by turning it into what is known as a Fragment, which is essentially creating a function from the query
    that is able to be called, and even pass parameters to it.
</p>
<pre>
    query getElementsFromWorkspace($workspaceId: String!){
        elements(workspaceId: $workspaceId, type: Shape) {
          __typename
          id
        }
      }
</pre>

<p>
    This is only the beginning of what is possible with GraphQL queries. To find out more about working with them in Bluescape 
    continue on to the next guides page on <a href="blank">Create a Canvas with a Text Element</a>
</p>